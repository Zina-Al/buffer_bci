function z = reval( procName, varargin )
% remotely evaluate a function using a batch-job-system, e.g. grid-engine, x-grid
%
% p = reval( procName, varargin )
% OR
% p = reval( nargout, procName, varargin ) 
% OR
% p = reval( optsStruct, procName, varargin )
%
% Inputs:
%  nargout - [int] number of output arguments from proc
%  optsStruct - [struct] set of reval options as generated by reval_conf
%  procName- [str] function to be executed
%  varargin- list of parameters for procName
% Options:
%  memUse - [int]	estimated memory in MB                     (100)
%  timeUse- [int]	estimated running time in minutes          (10)
%  coreUse- [int] number of cores on processor to use        (1)
%  express- [bool] use express queues                        (false)
%  hold   - [bool] put job on hold immediately               (false)
%  priority [bool] specify priority (-1023 to 0)             (1)
%  rerun  - [bool] rerun after crash                         (0)
%  verb   - [int] set verbosity level                        (1)
%  globals- [bool] save global state for running job         (0)
%  cwd    - [str] path to run command from                   (current directory)
%  description-[str] user description of this job            ('')
%  preflight - [str] string of matlab commands to run before procName ('')
%  smartpath - [bool] replace local-home in matlabpath with ~ remotely (1)
% Outputs:
%  z      - [struct] describing the submitted job
%  |.job  - job information
%  |    |.method -- [str] name of the function to call
%  |    |.nargout-- [int] number of output arguments to store
%  |    |.varargin-- {cell} set of input arguments
%  |    |.varargout--{cell} set of output arguments
%  |.conf -- job submission configuration information
%       |.jobname -- [str] name for the job
%       |.jobdir  -- [str] directory where job tempory files are stored
%       |.jobid   -- [str] UID for the job in the job system
%
%
% See Also: re_status, re_log, re_clean, re_getjobs, re_collect, re_resubmit

% Copyright 2006-     by Jason D.R. Farquhar (jdrf@zepler.org)

% Permission is granted for anyone to copy, use, or modify this
% software and accompanying documents for any uncommercial
% purposes, provided this copyright notice is retained, and note is
% made of any changes that have been made. This software and
% documents are distributed without any warranty, express or
% implied
numargout=[];
if ( isstruct(procName) ) % options structure
   opts=procName.opts;conf=procName.conf;procName=varargin{1};varargin(1)=[];numargout=conf.nargout;
elseif ( iscell(procName) ) % something else
   [conf,opts]=reval_conf(procName{:}); % default options
   procName=varargin{1};varargin(1)=[];numargout=conf.nargout;
else
   [conf,opts]=reval_conf();
end
if ( isnumeric(procName) ) % num output args
   numargout=procName; procName=varargin{1}; varargin(1)=[]; 
else
   if ( isempty(numargout) ) numargout=0; end;
end
job.method=procName;
job.nargout=numargout;
job.description=conf.description;
z.conf=conf;
z.opts=opts;
conf.varname            = 'varname'; % BODGE: stop template var-expansion warning

% create a new directory on the cluster-home to hold the job files
if ~exist(conf.jobrootdir)  system(['mkdir -p ' conf.jobrootdir]), end ;
if(isempty(conf.userprefix)) conf.userprefix=procName; end;

conf.jobdir=fullfile(conf.jobdir,conf.userprefix);
if ( ~exist(fullfile(conf.jobrootdir,conf.jobdir),'dir') ) mkdir(fullfile(conf.jobrootdir,conf.jobdir)); end;

% generate a unique job number and associated directory
jobdirs=dir(fullfile(conf.jobrootdir,conf.jobdir)); jobdirs(~[jobdirs.isdir])=[]; jobdirs={jobdirs.name};
jobdirs=sort(jobdirs);
if ( strfind(jobdirs{end},conf.userprefix)==1 )
   conf.jobnum=str2num(jobdirs{end}(numel(conf.userprefix)+2:end))+1;
else
   conf.jobnum=1;
end
conf.jobname=sprintf('%s_%04i',conf.userprefix,conf.jobnum);
while ( exist(fullfile(conf.jobrootdir,conf.jobdir,conf.jobname),'dir') )
   conf.jobnum=conf.jobnum+1;
   conf.jobname=sprintf('%s_%04i',conf.userprefix,conf.jobnum);
end
[success]=mkdir(fullfile(conf.jobrootdir,conf.jobdir,conf.jobname));
if ( ~success ) error('reval:jobdirunwriteable',sprintf('Couldnt make the job dir: %s',fullfile(conf.jobrootdir,conf.jobdir,conf.jobname))); end;
conf.jobdir=fullfile(conf.jobdir,conf.jobname);

% setup where we save stuff
conf.mastermfile = fullfile(conf.jobdir, conf.mastermfile);
conf.nodescript  = fullfile(conf.jobdir, conf.nodescript);
%
conf.subscript   = fullfile(conf.jobdir, [conf.jobname '-sub.sh']);
if( ~isempty(varargin) )
	conf.inputmatfile = fullfile(conf.jobdir, conf.inputmatfile);
else
	conf.inputmatfile = '';
end
if job.nargout
	conf.outputmatfile = fullfile(conf.jobdir, conf.outputmatfile);
else
	conf.outputmatfile = '';
end
conf.objectmatfile = fullfile(conf.jobdir, conf.objectmatfile);
conf.logfile = fullfile(conf.jobdir, conf.logfile);
conf.statusfile = fullfile(conf.jobdir, conf.statusfile);
conf.globalfile = fullfile(conf.jobdir, conf.globalfile);
% setup the working directory
if ( isempty(conf.cwd) )
   conf.cwd=cd();
   conf.cwd=strrep(conf.cwd,conf.home,'~/'); % fix rel to home dir
end

% setup the path info
if( opts.smartpath ) % replace unixhome in path with ~
   pth = path();   
   pth=strrep(pth,conf.home,'~/'); % fix rel to home dir
   % remove the normal system paths -- these should be added back in when matlab starts on remote machine
   [pathbits]=[0 find(pth==pathsep) numel(pth)];
   opth=pth;pth='';
   for i=2:numel(pathbits); 
      pthelm=opth(pathbits(i-1)+1:pathbits(i)-1);
      if( isempty(strmatch(matlabroot(),pthelm)) ) pth=[ pth pthelm pathsep() ]; end;
   end
   conf.matlabpath=pth;
else
   conf.matlabpath=path();
end

% save the input variables
if( ~isempty(varargin) )
	if( opts.verb >= 2 ) fprintf('saving function arguments in ''%s''...\n', conf.inputmatfile); end
	save(fullfile(conf.jobrootdir,conf.inputmatfile), 'varargin')
else
   conf.inputmatfile='';
end

if( opts.globals ) 
   gvars = whos('global');
   if( ~isempty(gvars) )
      if opts.verb >= 2, fprintf('saving global variables in ''%s''...\n',conf.globalfile); end
      globalstr = sprintf('%s ',gvars.name);
      globalfile= fullfile(conf.jobrootdir,conf.globalfile);
      saveglobals();
   else
      conf.globalfile=''; 
   end
else
   conf.globalfile=''; 
end

%-------------------------------------------------------------------------------------------------
% generate the submission scripts and the remote execution m-files

% generate the node script file
fid= fopen(opts.template.nodescript);str=fscanf(fid,'%c');fclose(fid);
str= varexpand(str,conf);
fd = fopen(fullfile(conf.jobrootdir,conf.nodescript), 'w+'); fprintf(fid,'%s',str); fclose(fid);
system(sprintf('chmod a+x "%s"', fullfile(conf.jobrootdir,conf.nodescript)));
if opts.verb >= 2
	fprintf('written "%s" :\n', conf.nodescript);
   fprintf('%s\n\n',str);
end


% generate master .m file
% compose matlab function call command line
callstr = job.method;
if ~isempty(varargin)
	callstr = [callstr '(varargin{:})'];
end
if( job.nargout>0 ) % save the requested output arguments to a file
	callstr = sprintf('[varargout{1:%d}]=%s;save(''%s'',''varargout'');',job.nargout,callstr,fullfile(conf.clusterhome,conf.outputmatfile));
end
conf.callstr=callstr;

% generate the .m script
fid= fopen(opts.template.mastermfile);str=fscanf(fid,'%c');fclose(fid);
str= varexpand(str,conf);
fd = fopen(fullfile(conf.jobrootdir,conf.mastermfile), 'w+'); fprintf(fid,'%s',str); fclose(fid);
if opts.verb >= 2
	fprintf('written "%s" :\n', conf.mastermfile);
   fprintf('%s\n\n',str);
end

% set the intial status
re_resetstatus(conf);
pause(1); % calls cannot be allowed to come too quickly after one another

% generate the submission command line
option_str=opts.optsstr.submit;
fn=fieldnames(z.opts); ostrfn=fieldnames(opts.optsstr);
for fi=1:numel(fn);
   fv=getfield(z.opts,fn{fi}); % only if is optstr opt in conf
   if(isempty(strmatch(fn{fi},ostrfn))) continue; end;
   if(~isempty(fv)) option_str=[option_str sprintf(getfield(opts.optsstr,fn{fi}),fv) ' ']; end;
end
option_str = [option_str sprintf(opts.optsstr.logfile,fullfile(conf.clusterhome,conf.jobdir)) ' ']; % log file
option_str = [option_str sprintf(opts.optsstr.nodescript,fullfile(conf.clusterhome,conf.nodescript)) ' ']; % node script to run
conf.sub_optstr= option_str;
conf.sub_cmd   = sprintf('%s %s %s',conf.sub_program,conf.sub_options,conf.sub_optstr);
if ( ~isempty(conf.sub_agent) )
   conf.sub_cmd = sprintf('%s %s',conf.sub_agent,conf.sub_cmd);
end

% submit the job
if( opts.verb > 0 ) 
   fprintf('Submitting job with cmd:\n%s\n',conf.sub_cmd);
end
[status,res]=system(conf.sub_cmd);
if ( status~= 0 ) 
   warning('%s\nsubmission failed with error code: %d',res,status);
   % mark status as failed
   fid=fopen(fullfile(conf.jobrootdir,conf.statusfile),'a'); fprintf(fid,'s.failed=%g;\n',datenum(now)); fclose(fid);
end
conf.res=res;
if( status==0 && ~isempty(opts.optsstr.getjobid)) % extract jobId from the submission response
   nn=strfind(res,sprintf('\n')); if ( numel(nn)>1 ) conf.res=conf.res(nn(end-1):end); end;
   conf.jobid=(strread(conf.res,opts.optsstr.getjobid))';
else
   conf.jobid=[];
end

% make and save the object file
z=struct('job',job,'conf',conf,'opts',opts);
save(fullfile(conf.jobrootdir,conf.objectmatfile),'-struct','z');
% write the jobId to a text file
fid=fopen(fullfile(conf.jobrootdir,conf.jobdir,sprintf('jobId=%s',conf.jobid)),'w'); fprintf(fid,'%s',conf.jobid); fclose(fid);

if( opts.verb >= 1 )
	fprintf('\nsubmit info:\n');
	fprintf('  job name           = %s\n', conf.jobname);
	fprintf('  job directory      = %s\n', conf.jobdir);
	fprintf('  qsub args          = %s\n', conf.sub_optstr);
	fprintf('  function           = %s\n', job.method);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function saveglobals
% horrible hack to save global variables as global variables
% N.B. need to use evalin to stop function parameter corrupting local variable space
eval(['global ' evalin('caller', 'globalstr')])  
eval(['save ''' evalin('caller', 'globalfile') ''''])

function [ostr]=varexpand(str,dict,strbgn,strend)
% expand variables in a string
%
% [str]=varexpand(str,dict[,strbgn,strend])
%
% Inputs:
%  str    -- [str] string to expand
%  dict   -- [struct] dictionary of variable names and values
%  strbgn -- [str] string denoting the start of var name to expand ('++')
%  strend -- [str] string denoting the end of var name expansion ('--')
if ( nargin < 3 || isempty(strbgn) ) strbgn='++'; end;
if ( nargin < 4 || isempty(strend) ) strend='--'; end;
bgns = strfind(str,strbgn); % all possible start positions
ends = strfind(str,strend); % all possible end positions
if ( isequal(strbgn,strend) ) bgns=bgns(1:2:end); ends=ends(2:2:end); end; % deal with equal-start/end
bgns = [-1 bgns]; 
ends = [1-numel(strend) ends]; 
ostr = '';
vnames = fieldnames(dict); 
for ei=2:numel(bgns); % loop over the possible epxansion locations
   ostr = [ostr str(ends(ei-1)+numel(strend):bgns(ei)-1)];
   vname=str(bgns(ei)+numel(strbgn):ends(ei)-1); % var name
   if ( isfield(dict,vname) )
      vali=getfield(dict,vname);
      if ( isnumeric(vali) ) ostr=[ostr sprintf('%g',vali)];
      elseif( isstr(vali) ) ostr=[ostr vali];
      else
         vstr=serialize(vali,'');
         vstr=strrep(vstr,'''','');
         ostr=[ostr vstr];         
         %warning('Can only expand strings or numerics, sorry'); 
      end
   else
      ostr=[ostr sprintf('%s%s%s',strbgn,vname,strend)];
      warning('no var named : %s',vname); 
      continue; 
   end;
end
ostr=[ostr str(ends(ei)+numel(strend):end)];
return;

function [varargout]=parseOpts(opts,varargin)
if ( ~iscell(opts) ) opts={opts}; end;
i=1; unrec=[];
while i<=numel(varargin);  % refined option parser with structure flatten
   if ( iscell(varargin{i}) ) % flatten cells
      varargin={varargin{1:i-1} varargin{i}{:} varargin{i+1:end}};
   elseif ( isstruct(varargin{i}) )% flatten structures
      cellver=[fieldnames(varargin{i}) struct2cell(varargin{i})]';
      varargin={varargin{1:i-1} cellver{:} varargin{i+1:end} };
   elseif ( isstr(varargin{i}) )
      fn=varargin{i}(1:min([find(varargin{i}=='.',1)-1,end]));
      sfn=varargin{i}(numel(fn)+2:end); % deal with name.subname
      for j=1:numel(opts); % assign fields, opts
         if( isfield(opts{j},fn) ) 
            if ( isstruct(opts{j}.(fn)) ) % recurse into sub-structs
               if ( ~isempty(sfn) )
                  varargin{i+1}=parseOpts(opts{j}.(fn),sfn,varargin{i+1});
               elseif( isstruct(varargin{i+1}) || iscell(varargin{i+1}) )
                  varargin{i+1}=parseOpts(opts{j}.(fn),varargin{i+1});
               end
            end
            opts{j}.(fn)=varargin{i+1}; i=i+1; j=0; break;
         end
      end      
      % record the unrec options
      if ( j>0 ) unrec(end+1)=i; if(i<numel(varargin)) i=i+1; unrec(end+1)=i;end; end 
      i=i+1;
   else
      unrec(end+1)=i;  % skip this unrecognised argument
      i=i+1;
   end
end
if ( numargout<=numel(opts) & ~isempty(unrec) )
   warning('Unrecognised Option(s) [#%s] ignored! ',sprintf('%d ',unrec));
end
varargout={opts{:} varargin(unrec)}; % return the unrecognised options

%-------------------------------------------------------------------------------------
function testCase()
reval('inv',randn(100,100))